# React dynamic list of Posts
- Replace `<your_account>` with your Github username in the
  [DEMO LINK](https://andriypt82.github.io/react_dynamic-list-of-posts/)
- Follow the [React task guideline](https://github.com/mate-academy/react_task-guideline#react-tasks-guideline)

## Task
You are given a basic markup and [the API](https://mate-academy.github.io/fe-students-api/).

Implement the app to manage post comments.

> Don't use class components. Use React Hooks instead. 

1. Create an `/src/api/posts.js` and add a method `getUserPosts(userId)` there 
1. Load posts and show them using the `PostsList` on page load. (use `useEffect` as a `componentDidMount`)
1. Implement the UserSelect to show only the posts of the selected user. (call `getUserPosts` each time when user changes)
1. Each post has an `Open` button that sets a `selectedPostId` in the `App`.
1. After opening the details the `Open` button becomes `Close` and will close the details onclick.
1. `PostDetails` component should be shown only after selecting a post.
1. Create `getPostDetails(postId)` method in `/src/api/posts.js` and load post details from `/posts/:postId`
1. Create `getPostComments(postId)` method in `/src/api/comments.js`, load comments from `/comments` and filter them using a given `postId`
1. Add a button to `show`/`hide` comments.
1. Add an `X` button near each comment to delete it on the server.
1. Add a form to add a new comment to the current post
1. Comments should be immediately updated after adding or removing.
 




 Java Script

 

 1) Let vs Var
  Почнемо з того що визначимо чим вони схожі.
    1) зміні типу let або var ми можемо оголосити не присвюючи їм значення відразу, присвоїти їм значення можна далі по коду в залежності від умови яка спрацє.
    2) змінні створенні через let або var можна змінювати не обмежену кіьлкість раз.
  А тепер в чому вони відрізня/ться:
    1) Зміна оголошенна через var видима з усіх областей видимості крім функціональної,
      Ми можемо створити змінну через var в циклі і доступитися до неї після завершення циклу.
    2) Ми можемо викликати змінну var ще до її створення, значення цієї змінної буде undefined.
    3) Ми можемо ініціалзувати нову змінну з імям яке вже було при створенні іншої змінної через var, ніякого конфліку не буде.

2) __proto__
  Прото це властивість яка присвоюється обєкту при її створенні. Все в JS є обєктами, і коли ми створюємо, наприклад, обєк'єкт const obj = {}, він наслідується від классу Object, що в свою чергу дозволяє доступатись до методів які прописані у прототипі класу Object. Proto цє getter/setter для звязку з Object. Через прото ми можемо як і доступатись до готових методів так і створювати свої.

3) Promise це обєкт який повертає результат асинхроної дії. Якщо в нашому коді є частина яка буде робити запити на сервер, щоб наша сторінка не блокуваласся в очікуванні результату, ми використовуємо проміс. Підписавшись під проміс ми повертаємось до виконання нашого синхроного коду, і як тіьки проміс завершиться, ми повертаємося до нього і отримуємо змогу опрацювати отриманий результат.

 Сам проміс приймає функцію callback, яка в свою чергу приймає 2 аргумента (функції): resolve i reject.
 Resolve відпрацьовує при успішному завершенні роботи проміса, reject спрацьовує при помилці.
 Після того як проміс спрацював ми підписуємося під цей проміс з допомогою метода then() або/і cath().
 В then результат попадає при успішному завершенні проміса, у catch при негативному. Також ми можемо підписати декільками  then() в ланцюзі. Що в свою чергу дозволяє при отриманні результату в перший then, обробити його і передати в наступний. Так само з catch, при спрацьовуванні cath ми можемо передати результат далі по ланцюгу, результат попаде в наступний then(). Також є метод finaly, який спрацює в кінці всіх обробок не зважаючи на позитивний чи негативий результат.

4) This. Це контекст виклику, вміст якого залежить від того де був викликаний this. Якщо this був викликаний у обекта асоціативного масиву то його контекст буде глобальний обєкт document,але якщо він викликаний в средені обекта в функції (метода цього обєкта), яка не оголошенна як стрілочна функція, то контекст this буде сам обєкт. Якщо ж наш обєкт був створений через конструктор то this, в цьому випадку буде мати контекст цього обекта. Є випадок коли і в створеному обєкті через конструктор this буде посилатися на глобальний обєкт document,це якщо ми, в нашому обєкті запустимо асинхрону дію.

5) Call stack. Ми можемо візуалізувати його як коробку в яку ми будемо класти дії які буде виконувати наш код.
Наприклад:
  У нас оголошенні 3 функції:
    func => "консоль-ложить" текст Всім Пивіт! і запускає другу функцію яка в свою чергу "консоль-ложить" текст Всім Папа!
  При запуску даного коду в стеку вже буде находитися функція main, це наш, запущений документ.
  Після цього в стек попадає наша func, в тілі нашої функції є метод console.log, який попадає наступним в стек, пілся чого він відпрацьовує і видаляється з стека (так як свою роботу він вже завершив). Далі, в нашій функції func знаходиться func2, яка попадає наступною в стек і запускається, в її тілі знаходиться метод console.log, який попадає в стек наступним. Коли console.log відпрацює, він видаляється з стека, після чого повертаємося в func2 і яка теж видаляється з стека, так як крім console.log там більше ніого не було, після чого таке саме відбуваєтсья з func, і на кінець видаляється main.

  Все так працює якщо у викликах наших функцій нема асинхроного коду. Якщо ж, до прикладу, в func2  ми помістимо асинхрону дію, після якої ще пропишемо concole.log, то після того як func2 попадає у стек, запускається наша асинхронна дія, яка в свою чергу не попадає в стек а попадає у webApi, так як асинхроні методи відносяться до функціоналу браузерів, вони їх і обробляють. Після того як асинхрона дія попала в WEBAPI у стек попадає console.log, який був прописаний в func2 пілся асинхроної дії. Після чого стек очищається в порядку який прописано вище не зважаючи на те що асинхрона дія ще не закінчилася.

  Після того як в WEBAPI наша функція завершилася, вона не попадає у call skack, у WEBAPI нема такої можливості, наша функція потрапляє в чегу завдань, яку постійно мониторить eventloop. Як тільки eventloop відловлює, що щось є в черзі завдань, він очікує коли спустошиться стек, щоб передати нашу функцію в стек для подальшого опрацювання. Але і тут може виникнути проблема, eventloop не може закинути в стек завдання поки він не очиститься, і якщо в стеку лежить ресурсо-затратна дія, то він буде чекати поки вона не завершиться але і після того як вона завершиться не завжди eventloop зможе відразу закинути в стек, так як є ще render queue, який рендерить сторінку близько 60 разів в секунду, і у якого пріоритет вищий ніж у eventloop. Тому у стек спочатку передастся з render queue.


 React


1) Ract це бібілотека, переваги якої полягають у :
  1) Компонентний підхід розробки. Написання коду ділиться на компоненти, які ми підключаємо в потрібному місці наошого проекта, також ми можемо використати цей компонент у інших проекта.
  2) Віртуальний дом (режим реконсиляції). Дозволяє не рендирити всю сторінку а тільки ті частини коду в яких відбулася змінна. Як це працює? При запуску проекта, рекат створює облегчену копію DOM дерева, і коли сторнка іде на рендерінг, реакт порівнює актуальний стан DOM дерева з облешченою копією (Virtual DOM). Після звікри з копією
